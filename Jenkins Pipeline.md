# jenkins Pipeline

    Jenkins is, fundamentally, an automation engine which supports a number of automation patterns. Pipeline adds a powerful set of automation tools onto Jenkins, supporting use cases that span from simple continuous integration to comprehensive CD pipelines.

## whole process

- scenario description and desin

- jenkins installation

- jenkins configuration and plugin setup

- podTemplate introduction

- pipeline description

## scenario description and design

    We have a jave demo and compile it. We build it into docker image with dockerfile. After that, we push this image into a image repository. During this whole process, we should use a jenkins running on kubernetes. We use a dynamic pod generated by our pipeline to install our dependencies and build the image. After pipeline, the dynamibc pod will be deleted. 

## jenkins installation

    First we need to deploy jenkins service in kubernetes using yaml file.

serviceAccount.yaml

```shell
kubectl apply -f serviceAccount.yaml -n devops-tools
```

```yaml
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: jenkins-admin
rules:
  - apiGroups: [""]
    resources: ["*"]
    verbs: ["*"]
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins-admin
  namespace: devops-tools
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: jenkins-admin
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: jenkins-admin
subjects:
- kind: ServiceAccount
  name: jenkins-admin
  namespace: devops-tools
```

volume.yaml

```shell
kubectl create volume.yaml -n devops-tools
```

```yaml
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: jenkins-pv-volume
  labels:
    type: local
spec:
  storageClassName: local-storage
  claimRef:
    name: jenkins-pv-claim
    namespace: devops-tools
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  local:
    path: /mnt
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - docker-desktop       # k8s work node
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: jenkins-pv-claim
  namespace: devops-tools
spec:
  storageClassName: local-storage
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 3Gi
```

deployment.yaml

```shell
kubectl apply -f deployment.yaml -n devops-tools
```

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jenkins
  namespace: devops-tools
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jenkins-server
  template:
    metadata:
      labels:
        app: jenkins-server
    spec:
      securityContext:
            fsGroup: 1000
            runAsUser: 0
      serviceAccountName: jenkins-admin
      containers:
        - name: jenkins
          image: jenkins/jenkins:lts
          resources:
            limits:
              memory: "2Gi"
              cpu: "1000m"
            requests:
              memory: "500Mi"
              cpu: "500m"
          ports:
            - name: httpport
              containerPort: 8080
            - name: jnlpport
              containerPort: 50000
          livenessProbe:
            httpGet:
              path: "/login"
              port: 8080
            initialDelaySeconds: 90
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 5
          readinessProbe:
            httpGet:
              path: "/login"
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          volumeMounts:
            - name: jenkins-data
              mountPath: /var/jenkins_home
      volumes:
        - name: jenkins-data
          persistentVolumeClaim:
              claimName: jenkins-pv-claim
```

service.yaml

```shell
kubectl create -f service.yaml -n devops-tools
```

```yaml
apiVersion: v1
kind: Service
metadata:
  name: jenkins-service
  namespace: devops-tools
  annotations:
      prometheus.io/scrape: 'true'
      prometheus.io/path:   /
      prometheus.io/port:   '8080'
spec:
  selector:
    app: jenkins-server
  type: NodePort
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 32000
```

    we can use some kubectl commands to check our jenkins service and pods. After deployment, we use some commands to get jenkins started and configured.

```shell
kubectl get pods -n devops-tools #get jenkins pod name
Kubectl exec -it podName cat /var/jenkins_home/secrets/initialAdminPassword -n devops-tools
#get jenkins initiallization password
```

### jenkins configuration and plugin setup

    After unlock jenkins, we need to install some basic plugins. These plugins help us pull code from github repo and deploy into a kubernetes pod with pipeline. Maven plugin is  needed for java project. 

![](C:\Users\I528814\AppData\Roaming\marktext\images\2023-04-30-08-05-06-image.png)

    github plugin configuration. This plugin helps us configure connection between kubernetes and github.

![](C:\Users\I528814\AppData\Roaming\marktext\images\2023-04-30-08-07-18-image.png)

    kubernetes plugin configuration. This plugin can set up kubernetes in jenkins.

![](C:\Users\I528814\AppData\Roaming\marktext\images\2023-04-30-08-07-50-image.png)

![](C:\Users\I528814\AppData\Roaming\marktext\images\2023-04-30-08-08-06-image.png)

![](C:\Users\I528814\AppData\Roaming\marktext\images\2023-04-30-08-08-18-image.png)

    Here jenkins URL stands for the access point for Jenkins service. We use nodeport to set up kubernetes connection, so we use jenkins service IP for jenkins URL.

```shell
kubectl get svc -n devops-tools -o wide # get jenkins service IP
```

 The jenkins tunnel helps the dynamic pod we create to connect with the jenkins pod. It uses TCP to communicate with our pods, so we use jenkins pod IP.

```shell
kubectl get pods -n devops-tools -o wide # get jenkins pod IP
```

![](C:\Users\I528814\AppData\Roaming\marktext\images\2023-04-30-08-12-12-image.png)

## podTemplate introduction

    pipeline is an importan part of jenkins. We use pipeline to build a process th  at pull the code and we build it into a image. After that, we use pipeline to deploy it into a kubernetes pod equipped with running environment.  During this whole process, we need to implement a brand new concept called podTemplate. podTemplate is used under the circusmtance which we want to generate a new pod to run our code. 

    Two basic podTemplates

```shell
 podTemplate(containers: [
    containerTemplate(
     name: 'maven',
     image: 'sunrdocker/jdk17-git-maven-docker-focal',
     command: 'cat',
     ttyEnabled: 'true')
  ])  

# image stands for the image repo you want
# command stands for the command that you want the image to run
# ttyEnabled if true, the dynamic pod will be deleted after pipeline


 podTemplate(yaml: '''
    apiVersion: v1
    kind: Pod
    spec:
      containers:
      - name: maven
        image: sunrdocker/jdk17-git-maven-docker-focal
        command:
        - cat
        tty: true
''') 

# podTemplate in yaml 
```

## pipeline description

    This pipeline script has four crucial stages. First, we use podTemplates to import two dynamic pods we will use. After that, we clone the code from github repo. We use Maven to pack our java code. Then we use kaniko to build image within kubernetes pod. At last, we deploy it into kubernetes with yaml file.

```shell
podTemplate(containers: [
    containerTemplate(name: 'maven', image: 'sunrdocker/jdk17-git-maven-docker-focal', command: 'cat', ttyEnabled: 'true'),
    containerTemplate(name: 'kubectl', image: 'uhub.service.ucloud.cn/uk8sdemo/kubectl:latest', command: 'cat', ttyEnabled: 'true'),
  ],
  yaml: """\
apiVersion: v1
kind: Pod
metadata:
  name: kaniko
spec:
  containers:
  - name: kaniko
    image: uhub.service.ucloud.cn/uk8sdemo/executor:debug
    command:
    - cat
    tty: true
    volumeMounts:
      - name: kaniko-secret
        mountPath: /kaniko/.docker
  restartPolicy: Never
  volumes:
    - name: kaniko-secret
      secret:
        secretName: regcred
    """.stripIndent()

  )
# three dynamic pods
# maven provides the mvn build tool
# kubectl provides the kubectl cmds
# kaniko provides the tool to build images in kubernetes
  {
    node(POD_LABEL) {
        stage('Git Clone')
        {
            git branch: 'main', credentialsId: 'a9245f23-3644-4bc1-8ff3-9edd068958c9', url: 'https://github.com/DennnnyX/htmx.git'
        }
        stage('Compile')
        {
            container('maven')
            {
                stage('mvn packaging')
                {
                    sh 'java -version'
                    sh 'mvn -version'
                    sh 'mvn clean package'
                }
            }
        }
        stage('Build Into Image')
        {
            container('kaniko')
            {
                stage('Build With Kaniko')
                {
                    echo 'Hello Kaniko'
                    echo 'Using Kaniko to Build Image'
                    sh "/kaniko/executor --dockerfile `pwd`/Dockerfile --context `pwd` --destination dennnys/pipeline:v1.1"
                }
            }
        }
        stage('Deploy Into Pod')
        {
            container('kubectl')
            {   
                withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECONFIG')])
                {
                     echo 'Check kubernetes pods'
                     sh 'mkdir -p ~/.kube && cp ${KUBECONFIG} ~/.kube/config' 
                     sh 'kubectl get pods'
                     sh 'kubectl apply -f deploy.yaml'
                     sh 'kubectl get pods -n devops-tools'
                     sh 'kubectl get svc -n devops-tools'
                }

            }
        }

    }
}
```

- podTemplate setup
  
      In this pipeline, we use three podTemplates. These three dynamic pods provide the basic environment for our pipeline. Such as mvn, kubectl and kaniko.   

- Git Clone
  
     In this stage, we use git command to pull code from github repo.

- Compile
  
     In this stage, we use maven to pack the java code into jar files. 

- Build into image
  
     In this stage, we use kaniko. Kaniko is a tool to build images from Dockerfile inside a kubernetes pod. The kaniko executor image is responsible for building an image from a Dockerfile and pushing it to a registry. Within the executor image, we extract the filesystem of the base image (the FROM image in the Dockerfile). We then execute the commands in the Dockerfile, snapshotting the filesystem in userspace after each one
  
  Dockerfile

```dockerfile
FROM sunrdocker/jdk17-git-maven-docker-focal

COPY /target/*.jar /app.jar

CMD ["--server.port=8080"]

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

- Deploy into pod

    After building into image, the demo should be deployed into a pod in kubernetes. We use yaml file to define the pod environment we want to deploy into. 

```yaml
apiVersion: apps/v1
kind: Deployment  
metadata:        
  name: java-demo  
spec:              
  replicas: 1    
  selector:
    matchLabels: 
      project: www
      app: java-demo
  template:
    metadata:
      labels:
        project: www
        app: java-demo
    spec:          
      imagePullSecrets:
        - name: java-demo
      containers:
        - image: dennnys/pipeline:v1.1
          name: java-demo
          resources:  
            requests:
              cpu: 0.5
              memory: 500Mi
            limits:
              cpu: 1
              memory: 1Gi

---
apiVersion: v1
kind: Service   
metadata:
  name: htmx-demo  
spec:
  selector:
    project: www
    app: java-demo
  type: NodePort  
  ports:
    - protocol: TCP
      port: 8080   
      targetPort: 8080   
```

    We deploy pod using this yaml with pipeline. We need a image with kubectl to deploy pods. We need to upload our kubeconfig file to jenkins and let jenkins have access to this file so that we can use kubectl to connect to the cluster. 

```shell
        stage('Deploy Into Pod')
        {
            container('kubectl')
            {   
                withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECONFIG')])
                {
                     echo 'Check kubernetes pods'
                     sh 'mkdir -p ~/.kube && cp ${KUBECONFIG} ~/.kube/config' 
                     sh 'kubectl get pods'
                     sh 'kubectl apply -f deploy.yaml'
                     sh 'kubectl get pods -n devops-tools'
                     sh 'kubectl get svc -n devops-tools'
                }

            }
        }
```

    After deploying into kubernetes, we have a pod with java demo. We use pod-forward to tansfer a local port to kubernetes port. Then we can have access to java demo with local port. 

```shell
kubectl port-forward podName 28015:27017
# 28105 is local port
# 27017 is kubernetes port
```
